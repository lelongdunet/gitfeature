#!/bin/bash
# Copyright (c) 2012-2013 Adrien LELONG
#
# This script implement the git feature subcommand
# View README file for more details.


PYPATH="$(dirname "$(readlink -f "$0")")"/../python
CMDFEATCACHE="python $PYPATH/featmain.py"
TMPFILE=/tmp/featuretmp.$USER
HOOKRELPATH=../hooks
VER="v0.2.02"


if ! GITDIR="$(git rev-parse --git-dir)"; then
    exit 1
fi

cd "$GITDIR/.."
GITDIR=.git

if [ "$1" == "_featcache" ]; then
    shift
    set -e
    export DEVREF=$(git config workflow.devref)
    export REMOTE=$(git config workflow.remote)
    $CMDFEATCACHE $@
    exit
fi

################################################################################
#   Manage colors (see http://wiki.bash-hackers.org/scripting/terminalcodes )
################################################################################

GREEN="\\033[1;32m"
NORMAL="\\033[0;39m"
RED="\\033[1;31m"
PINK="\\033[1;35m"
BLUE="\\033[1;34m"
WHITE="\\033[0;02m"
LIGHT="\\033[1;08m"
YELLOW="\\033[1;33m"
CYAN="\\033[1;36m"
UNDERLINE="\\033[04;39m"
INVERTED="\\033[07;39m"
BLINK="\\033[05;39m"
BOLD="\\033[01;39m"
GREENBOLD="\\033[01;32m"


ERRCOL="$NORMAL$RED"
WARNCOL="\\033[0;37;44;1m"
IMPORTANT="$NORMAL$UNDERLINE$GREEN"
TITLE="$NORMAL$UNDERLINE$BOLD"
HIGHLIGHT="$NORMAL$GREENBOLD"

echoerr()
{
    echo -e "$ERRCOL$1$NORMAL" >&2
}

echowarn()
{
    echo -e "$WARNCOL$1$NORMAL"
}

echoimportant()
{
    echo -e "$IMPORTANT$1$NORMAL"
}

repeatchar()
{
    A=$(seq $1)
    echo ${A//??/$2}
}

menuselect()
{
    echo "-----------------"
    if [ "$3" == '-d' ]; then
        MENUITEMS="$1"
    else
        MENUITEMS="$(echo -e "$1" | cat -n)"
    fi
    if ! dialog --menu "$2" 50 130 50 $MENUITEMS  2> "$TMPFILE"; then
        return 1
    fi
    echo -e "$MENUITEMS" | sed "/^\s*$(<"$TMPFILE")\s/!D;s/^\s*\w*\s*//" > "$TMPFILE"
}

multiselect()
{
    echo "-----------------"
    #MENUITEMS="$(echo -e "$1" | cat -n)"
    if ! dialog --checklist "$2" 50 130 50 $1  2> "$TMPFILE"; then
        return 1
    fi
}

function is_local()
{
    git rev-parse refs/heads/$1 &> /dev/null && return 0
    return 1
}


initialize()
{
    if INST_VER=$(git config workflow.feature); then
        if [ "$INST_VER" == "$VER" ]; then
            echo "Feature management already initialized"
            return
        else
            echo "Update git feature from $INST_VER to $VER"
            UPDATE=1
        fi
    fi

    if [ ! "$UPDATE" == 1 ]; then
        git config workflow.fetchinter 24

        CANDIDATES=$(git branch -a | \
            sed '/(.*)/D;/final\//D;
        /draft\//D;
        /start\//D;
        /test\//D;
        /tmp\//D;
        /->/D;s/^.\s*//')
        if ! menuselect "$CANDIDATES" "Choose the main devel branch"; then
            echo ""
            echo "Initialization aborted"
            exit
        fi
        DEVREF=$(<"$TMPFILE")


        if ! menuselect "$(git remote)" "Choose your public repo where you will push"; then
            echo ""
            echo "Initialization aborted"
            exit
        fi

        REMOTE=$(<"$TMPFILE")
        git config workflow.devref "$DEVREF"
        git config workflow.remote "$REMOTE"
        if is_local $DEVREF; then
            git update-ref refs/markers/devref $DEVREF
        fi
    fi

    #Install hook
    HOOKPATH="$(dirname "$(readlink -f "$0")")/$HOOKRELPATH"
    echo "Getting hooks from $HOOKPATH"
    if ! cp -a "$HOOKPATH/"* "$GITDIR/hooks/"; then
        exit
    fi

    git config workflow.feature $VER

    #Set alias
    git config alias.featpush "feature -p"
    git config alias.featmove "feature -m"
    git config alias.featreview "feature -r"
    git config alias.featfinalize "feature -f"
    git config alias.featupdate "feature -u"
    git config alias.featintegrate "feature -i"
    git config alias.featview "feature -v"
    git config alias.featlist "feature -l"
    git config alias.feattest "feature -T"
    git config alias.featclear "feature -a clear"
    git config alias.featco "feature -a checkout"

    git config --unset alias.featcherry
    git config --unset alias.featclose
    git config --unset alias.featviewall
    git config --unset alias.featpushall
}

cleanoldfeat()
{
    LIST=$($CMDFEATCACHE featmainbranch state=draft,final local integrated sort=time old=2592000)
    SELECTLIST=''
    count=0
    for feat in $LIST; do
        SELECTLIST=" $feat $(basename $feat) on $SELECTLIST"
        count=$((count+1))
    done
    #Only continue if there is more than 10 features to remove
    if [ "$count" -lt 10 ]; then
        return
    fi

    if ! multiselect "$SELECTLIST" "These old integrated will be deleted unless you want to archive it."; then
        $CMDFEATCACHE sync integration
        return
    else
        SELECTED=$(sed 's/"//g;s/\\#/#/g' "$TMPFILE")
    fi

    for feat in $SELECTED; do
        branches=$($CMDFEATCACHE locals $feat)
        for branch in $branches; do
            echo "Remove branch $branch"
            git branch -D "$branch"
        done
    done
    $CMDFEATCACHE
    LIST=$($CMDFEATCACHE featmainbranch state=draft,final local integrated sort=time old=4592000)
    echo "Archive unselected features"
    for feat in $LIST; do
        echo "Archive $feat"
        git branch -m "$feat" "archive/$(basename "$feat")"
    done
    $CMDFEATCACHE
}

unicref()
{
    count=0
    name=$1
    while git rev-parse $name$count &> /dev/null; do
        count=$((count+1))
    done

    echo $name$count
}

display_ver()
{
    echo "Git feature $VER"
    echo ""
}

usage()
{
cat << EOF
usage: git feature options

This script create new and manage feature branches :
git feature [options] featurename

Default action is creating a new branch, other are provided through options
OPTIONS:
   -a      Perform the given action
            > close : Check the feature is integrated and destroy all branches
            > clear : Interactively close included features
            > cherry : look for commits that are (not) cherry-picked in DEVREF
                - accept reverse option -R for "not"
            > checkout : checkout the main branch of the given feature
            > devref : Change the devref ( it must always contain the old one )
            > files : list files modified in all commits of the feature
            > diff : show all patch (overall diff) of the feature (all commits together)
            > finalize : Finalize the feature
            > init : Initialize current repository to handle features
            > merge : Merge all features in a single branch
            > update : Update the specified feature using rebase
            > view : View local features and there remote updates
                - accept full option -F to see all commits of DEVREF
            > version : Display git feature version
            > view all : View local features and all updated remote features
   -b      Give a specific branch on which to base the new feature
   -c      Check feature (push and final)
   -f      Finalize the feature.
   -h      Display this help.
   -i      Include feature in current branch
                - accept -R (revert) option to cancel last integration
   -l      List all features and indicate if local features must be pushed or not
                - accept -S (silence) to hide information about status
                - accept -D (date) to sort all display by date
   -m      Move the feature upon a new base
                > Specify the feature on which you want to move the current feature
   -p      Push the given feature
                > Update all features if 'all' specified.
   -r      Review commits of the branch ( git rebase -i )
   -t      Dummy option for test purpose.
   -T      Make a test branch
                > Allows to interactively select features to try to merge together.
   -u      Update the specified feature using rebase (Same as -a update )
   -U      Update remote DEVREF and tags (integrator only)
   -v      View local features in gitk. Or if a remote name is specified, view
                all features of this repository

ALIAS:
The following alias can be used:
    > featpush			"feature -p"
    > featmove			"feature -m"
    > featclear			"feature -a clear"
    > featco            "feature -a checkout"
    > featreview		"feature -r"
    > featfinalize		"feature -f"
    > featupdate		"feature -u"
    > featintegrate		"feature -i"
    > feattest			"feature -T"
    > featview			"feature -v"    (see -a view)
    > featlist			"feature -l"

EOF
}

################################################################################
#   Get arguments
################################################################################

DO='n' # Default action is new feature

while getopts "AFrfm:tb:a:hucvpliRSUsTLD" OPTION; do
    case $OPTION in
        a)
            case $OPTARG in
                merge)
                    echo 'Merge not implemented yet.'
                    exit
                    ;;
                finalize)
                    DO='f'
                    ;;
                init)
                    echo 'Initializing feature management in your repo'
                    initialize devel
                    exit
                    ;;
                cherry)
                    DO='Y'
                    ;;
                checkout)
                    DO='co'
                    ;;
                devref)
                    DO='d'
                    EXPECTED=1
                    ;;
                diff)
                    DO='diff'
                    ;;
                files)
                    DO='files'
                    ;;
                view)
                    DO='v'
                    EXPECTED=1
                    ;;
                clear)
                    DO='D'
                    EXPECTED=1
                    ;;
                update)
                    DO='u'
                    ;;
                close)
                    DO='C'
                    ;;
                version)
                    display_ver
                    exit
                    ;;
				tags)
					DO='tags'
					EXPECTED=none
					;;
            esac
            ;;
        A)
            ALL='y'
            ;;
        F)
            FULL='y'
            ;;
        R)
            REVERSE='y'
            ;;
        S)
            SILENT='y'
            ;;
        D)
            DATESORT='y'
            ;;
        c)
            DO='c'
            ;;
        b)
            FOLLOW=$OPTARG
            ;;
        u)
            DO='u'
            ;;
        m)
            MOVETO=$OPTARG
            DO='m'
            ;;
        r)
            DO='r'
            ;;
        f)
            DO='f'
            ;;
        t)
            DO='t'
            ;;
        L)
            DO='L'
            EXPECTED=none
            ;;
        i)
            DO='i'
            OPTFEATARG='y'
            ;;
        l)
            DO='l'
            EXPECTED=1
            ;;
        v)
            DO='v'
            EXPECTED=1
            ;;
        p)
            DO='p'
            ;;
        U)
            DO='U'
            EXPECTED=none
            ;;
        s)
            DO='s'
            ;;
        T)
            DO='T'
            EXPECTED=1
            ;;
        h)
            usage
            exit
    esac
done

shift $((OPTIND-1))
if [ "$EXPECTED" == none ]; then
    if [ $# -gt 0 ]; then
        echoerr "No args expected! "
        exit 1
    fi
elif [ -n "$EXPECTED" ]; then
    ARG=$1
elif [ $# == 1 ]; then
    FEATUREBRANCH="${1//[[:space:]]/}"
elif [ "$OPTFEATARG" == "y" ]; then
    FEATUREBRANCH=""
elif test "$DO" != 'n' && CURRENT=$(git symbolic-ref HEAD 2> /dev/null); then
    FEATUREBRANCH=${CURRENT##refs/heads/}
else
    usage
    exit 3
fi

if [ -n "$FEATUREBRANCH" ]; then
    FEATURE=$(basename $FEATUREBRANCH)
elif [[ -z "$EXPECTED" && -z "$OPTFEATARG" ]]; then
    echoerr "No feature name or branch provided!"
    exit 1
fi

################################################################################
#   Check and prepare environment
################################################################################

INST_VER=$(git config workflow.feature)
if [[ ! "$INST_VER" == "$VER" ]]; then
    echoerr "Feature is not installed or needs to be updated"
    echo "Run git feature -a init"
    exit -1
fi

if ! DEVREF=$(git config workflow.devref); then
    echoerr "The git config workflow.devref parameter must be define"
    exit 6
fi
export DEVREF
export REMOTE=$(git config workflow.remote)

## Synchronize featcache
if ! EVENTS="$($CMDFEATCACHE sync)"; then
    echoerr "Error while syncing cache."
    echo " > check python-dulwich package is installed."
    exit 7
fi

if [ -n "$EVENTS" ]; then
    eval "$EVENTS"

    if [ -n "$integration" ]; then
        #Check old integrated features (older than 1 month)
        cleanoldfeat
    fi
fi

STARTNAMESPACE='start'
DRAFTNAMESPACE='draft'
FINALNAMESPACE='final'
FEATURESTART="$STARTNAMESPACE/$FEATURE"
FEATUREDRAFT="$DRAFTNAMESPACE/$FEATURE"
FEATUREFINAL="$FINALNAMESPACE/$FEATURE"

if [ ! "$FEATURE" == "$FEATUREBRANCH" ]; then
    FEATUREDIR="$(dirname "$FEATUREBRANCH")"
    FEATURENAMESPACE="$(basename "$FEATUREDIR")"

    if [[ ! ( "$FEATURENAMESPACE" == "$DRAFTNAMESPACE" || "$FEATURENAMESPACE" == "$FINALNAMESPACE" ) ]]; then
        echoerr "Invalid domain $FEATURENAMESPACE.\
            You must provide a $FEATUREDRAFT or a $FEATUREFINAL feature branch."
        exit 20
    fi
else
    if [[ $# == 0 && -z "$EXPECTED" && -z "$OPTFEATARG" ]]; then
        echoerr "You are not in a feature branch"
        echoerr "Either checkout the branch or provide the feature name in command line"
        exit 1
    fi
fi

################################################################################
#   Function definitions
################################################################################

function list_feattags()
{
    START=$1
	if [ -z "$2" ]; then
		REFS=$1
	else
		END=$2
		REFS=$START..$END
	fi

    git rev-list --simplify-by-decoration --pretty='format:%d' $REFS \
        |sed '/[ (,]@[^(),]\+_\w\+/!D;s/^\s*([^)@]*\(@[^(),]\+_\w\+\).*$/\1/'
}

function start_point()
{
    WORKINGBRANCH=$1
    $CMDFEATCACHE start $WORKINGBRANCH
}

function feature_root()
{
    $CMDFEATCACHE root $1
}


function branch_list()
{
    git branch $@ | sed 's/^.\s*//'
}

function check_included()
{
    featbranch=$1
    featname=$(basename $featbranch)
    git rev-list $DEVREF ^$featbranch^ --simplify-by-decoration --pretty='format:%d' \
        |egrep '@'$featname'_[0-9]{1,}\b' &> /dev/null \
        && return 0

    return 1
}

function check_remote()
{
    ERR=0
    LIST=$(git branch -r --list "$REMOTE/$FINALNAMESPACE"'/*')
    LIST="$LIST $(git branch -r --list "$REMOTE/$DRAFTNAMESPACE"'/*')"
    for b in $LIST; do
        feat=$(basename $b)
        if git rev-parse $STARTNAMESPACE/$feat &> /dev/null; then
            if ! git rev-parse $REMOTE/$STARTNAMESPACE/$feat &> /dev/null; then
                echo "# > Feature $feat is not correctly pushed! You must run"
                echo "git push $REMOTE $STARTNAMESPACE/$feat"
                ERR=1
            fi
        fi
    done
    return $ERR
}

function feat_local_branches()
{
    BRANCHES=''
    featname=$1
    if git rev-parse draft/$featname &> /dev/null; then
        BRANCHES=" draft/$featname"'\n'
    fi
    if git rev-parse start/$featname &> /dev/null; then
        BRANCHES="$BRANCHES start/$featname"'\n'
    fi
    if git rev-parse final/$featname &> /dev/null; then
        BRANCHES="$BRANCHES final/$featname"'\n'
    fi

    echo "$BRANCHES"
}

function feat_list()
{
    ALLFEATS="$(branch_list --list 'final/*')"
    if [ "$2" != "l" ]; then
        ALLFEATS="$ALLFEATS"'\n'"$(branch_list -r --list '*/final/*')"
    fi
    ALLFEATS="$ALLFEATS"'\n'"$(branch_list --list 'draft/*')"
    if [ "$2" != "l" ]; then
        ALLFEATS="$ALLFEATS"'\n'"$(branch_list -r --list '*/draft/*')"
    fi

    ALLFEATS="$(echo -e "$ALLFEATS"|python "$PYPATH/filters.py" "$REMOTE")"


    #Separate included / not included features
    for feat in $ALLFEATS; do
        if check_included $feat; then
            FEATINC="$FEATINC$feat"'\n'
        else
            FEATCUR="$FEATCUR$(basename $feat)"'\n'
            FEATCURBRANCH="$FEATCURBRANCH$feat"'\n'
        fi
    done

    case "$1" in
        i)
            echo -e "$FEATINC"
            ;;
        c)
            echo -e "$FEATCUR"
            ;;
        b)
            echo -e "$FEATCURBRANCH"
            ;;
    esac
}

################################################################################
#   Proceed
################################################################################
#TODO : Display current features errors as Warning (force the user to confirm)
#           but don't block all the workflow for one error on one branch
#if test "$DO" != 'p' && ! check_remote; then
#    exit 1
#fi


#Change DEVREF
if [ "$DO" == 'd' ]; then
    #git branch --contains $DEVREF
    if test -n "$ARG" && git rev-parse "$ARG" &> /dev/null ; then
        NEWREF=$ARG
        #Check if new reference contains old reference
        if [ -n "$(git rev-list $DEVREF ^$NEWREF)" ]; then
            echoerr "The new devel reference must contain $DEVREF"
            exit 1
        fi
    else
        CANDIDATES=$(git branch --contains $DEVREF | sed 's/^.\s*//')
        if [ -n "$CANDIDATES" ]; then
            CANDIDATES=$CANDIDATES"\n"
        fi
        CANDIDATES=$CANDIDATES$(git branch -r --contains $DEVREF | sed 's/^.\s*//')
        menuselect "$CANDIDATES" "Choose the main devel branch"
        NEWREF=$(<"$TMPFILE")
    fi

    echo ""
    echoimportant "New devel reference is $NEWREF"
    git config workflow.devref $NEWREF
    if is_local $NEWREF; then
        git update-ref refs/markers/devref $NEWREF
    fi
    $CMDFEATCACHE
    exit

elif [ "$DO" == 'tags' ]; then
	list_feattags $DEVREF
	exit

elif [ "$DO" == 'U' ]; then
    echo "Update remote devel reference : $DEVREF"
    echo git push $REMOTE $DEVREF
    git push $REMOTE $DEVREF && \
    git push $REMOTE $(list_feattags refs/markers/devref $DEVREF) && \
    git update-ref refs/markers/devref $DEVREF
    exit

elif [ "$DO" == 'diff' ]; then
    STARTPOINT=$(feature_root $FEATUREBRANCH) || exit 1
    git diff "$STARTPOINT" "$FEATUREBRANCH"
    exit

elif [ "$DO" == 'files' ]; then
    STARTPOINT=$(feature_root $FEATUREBRANCH) || exit 1
    git diff --name-only "$STARTPOINT" "$FEATUREBRANCH"
    exit

elif [ "$DO" == 's' ]; then
    $CMDFEATCACHE shortstate $FEATUREBRANCH
    exit

#Close the feature
elif [ "$DO" == 'C' ]; then
    if ! $CMDFEATCACHE isintegrated $FEATUREBRANCH &> /dev/null; then
        echoerr "Integration tag not found. The feature cannot be closed"
        exit 1
    fi

    git rev-parse $FEATUREDRAFT &> /dev/null && git branch -D $FEATUREDRAFT
    git rev-parse $FEATUREFINAL &> /dev/null && git branch -D $FEATUREFINAL
    git rev-parse $FEATURESTART &> /dev/null && git branch -D $FEATURESTART

    $CMDFEATCACHE
    exit

elif [ "$DO" == 'Y' ]; then
    FEATUREBRANCH=$($CMDFEATCACHE branch $FEATUREBRANCH)
    git rev-list --cherry-pick --right-only --pretty=full $DEVREF...$FEATUREBRANCH
    exit

elif [ "$DO" == 'D' ]; then
    LIST="$(feat_list 'i' 'l')"
    for feat in $LIST; do
        COMMITDATE=$(git log -n1 --pretty=format:%ct $feat)
        LASTCOMMIT=$(git log -n1 --pretty=format:%cr $feat|sed 's/ /_/g')
        SELECTLIST="$SELECTLIST$COMMITDATE $feat $(basename $feat):($LASTCOMMIT) off"'\n'
    done
    SELECTLIST=$(echo -e "$SELECTLIST"|sort -n|sed 's/^\w*\s*//')

    if ! multiselect "$SELECTLIST" "Select features you want to merge in test branch"; then
        SELECTED=''
    else
        SELECTED=$(sed 's/"//g;s/\\#/#/g' "$TMPFILE")
    fi

    if [ -z "$SELECTED" ]; then
        echo ""
        echo "No feature selected for cleaning"
        exit
    fi

    BRANCHLIST=''
    for feat in $SELECTED; do
        BRANCHLIST="$BRANCHLIST$(feat_local_branches $(basename $feat))"
    done

    TITLE="The following branches will be deleted. Are you sure?"
    if dialog --title "$TITLE" --yesno "$BRANCHLIST" 40 120; then
        BRANCHLIST=$(echo -e $BRANCHLIST)
        for branch in $BRANCHLIST; do
            echo " > Deleting $branch"
            git branch -D $branch
        done
        repeatchar 70 '-'
    else
        echo "Deletion canceled."
    fi
    $CMDFEATCACHE
    exit


elif [ "$DO" == 'i' ]; then
    FEATREBASEDIR="$GITDIR/feat_rebase"
    if [ -f "$FEATREBASEDIR/integration" ]; then
        echoimportant "JUST CLEAN THE PREVIOUS INTEGRATION"
        FEATURE="$(<"$FEATREBASEDIR/integration")"
        POSTCHECKOUT="$(<"$FEATREBASEDIR/postcheckout")"
        test -n "$POSTCHECKOUT" && git checkout "$POSTCHECKOUT" &&
        test -n "$FEATURE" && git branch -D "integrate/$FEATURE" &&
        rm "$FEATREBASEDIR"/* &&
        echo "Integration succesfull"
        exit
    fi
    #Check if repo is clean
    if ! git diff --quiet HEAD; then
        echoerr "Your repository must be clean"
        echo "Please commit all changes before running it!"
        exit 2
    fi

    if ! CURRENT=$(git symbolic-ref HEAD 2> /dev/null); then
        echoerr "You must be in a valid local branch for include operation!"
        exit 1
    fi
    #Check current branch is not a feature
    if $CMDFEATCACHE isfeaturebranch "$CURRENT"; then
        echoerr "You are in feature branch. Be carefull!"
        exit 2
    fi
    CURRENTBRANCH=${CURRENT##refs/heads/}

    if [ "$REVERSE" == "y" ]; then
        #TODO Retrieve history using featcache
        echo "Reverting last included feature..."
        TAGNAME=$(git tag -l --contains $CURRENTBRANCH '@*_*')
        if [ -z "$TAGNAME" ]; then
            echoerr "No valid tag found!"
            exit 3
        fi
        echo " > Remove $TAGNAME and go back in $CURRENTBRANCH"
        git tag -d "$TAGNAME"
        git reset --hard $CURRENTBRANCH@{1}
        exit
    fi

    if [ -z "$FEATURE" ]; then
        echoerr "A feature must be specified!"
        exit 4
    fi

    echo "Including $FEATURE in $CURRENTBRANCH"
    if ! FINALS="$($CMDFEATCACHE finals "$FEATURE")"; then
        exit 100
    fi

    if [ -z "$FINALS" ]; then
        echo "No final branch found for inclusion of $FEATURE"
        exit 1
    fi

    DEP_FEAT=$($CMDFEATCACHE depend "$FEATURE")
    if [ "$DEP_FEAT" != "None" ]; then
        if ! $CMDFEATCACHE isintegrated "$DEP_FEAT" 2> /dev/null; then
            echoerr "Dependancies must be integrated!"
            echo "Integrate dependency $DEP_FEAT before!"
            exit 10
        fi
    fi

    if [ $(echo -e "$FINALS" | wc -l) == 1 ]; then
        CHOSENFINAL="$FINALS"
    else
        if ! menuselect "$FINALS" "Choose a final reference for the feature $FEATURE"; then
            exit
        fi
        CHOSENFINAL=$(<"$TMPFILE")
    fi

    #Get NEWBASE SHA-1
    NEWBASE=$(git rev-parse HEAD)
    STARTPOINT=$(start_point $FEATUREBRANCH) || exit 1
    #TODO Check dependencies

    if [ "$STARTPOINT" == "$(git rev-parse HEAD)" ]; then
        git rebase $CHOSENFINAL
        git tag '@'$FEATURE"_$(date '+%s')"
    else
        FEATUREINTEGRATE=integrate/$FEATURE
        echo ''
        echo git branch -f $FEATUREINTEGRATE $CHOSENFINAL
        git branch -f $FEATUREINTEGRATE $CHOSENFINAL

        export INTEGRATION=$FEATURE
        export POSTCHECKOUT=$CURRENTBRANCH
        echo git rebase --onto $NEWBASE $STARTPOINT $FEATUREINTEGRATE
        git rebase --onto $NEWBASE $STARTPOINT $FEATUREINTEGRATE
    fi
    $CMDFEATCACHE

    exit

#Push feature
elif [ "$DO" == 'p' ]; then
    if [ "$FEATURE" == 'all' ]; then
        LIST=$($CMDFEATCACHE pushlist updateall)
    else
        echo "Pushing feature $FEATURE"
        LIST=$($CMDFEATCACHE pushauto "$FEATURE")
    fi
    for branch in $LIST; do
        git push -f $REMOTE $branch
    done
    $CMDFEATCACHE
    exit

#Check feature
elif [ "$DO" == 'c' ]; then
    exit

#View using gitk
elif [ "$DO" == 'v' ]; then
    BRANCHLIST=""
    echo "Getting list of branch ..."
    if [[ "$ALL" == 'y' || "$ARG" == all ]]; then
        BRANCHLIST="$($CMDFEATCACHE featbranches state=draft,final)"
    elif [ -n "$ARG" ]; then
        REMOTENAME="$ARG"
        BRANCHLIST="$($CMDFEATCACHE featbranches state=draft,final featuser=$REMOTENAME)"
    else
        BRANCHLIST="$($CMDFEATCACHE featbranches state=draft,final local)"
    fi

    if [ "$FULL" == 'y' ]; then
        BRANCHLIST="$BRANCHLIST $DEVREF"
    else
        BRANCHLIST="$BRANCHLIST $DEVREF ^$DEVREF^"
    fi
    echo $BRANCHLIST
    echo "---------------------------------------"
    gitk $BRANCHLIST &

    exit

#List features
elif [ "$DO" == 'l' ]; then
    #If ARG is not empty it is the remote name
    if [[ "$ALL" == 'y' || "$ARG" == all ]]; then
        FILTER=''
    elif [ -z "$ARG" ]; then
        FILTER=';local'
    else
        FILTER=";featuser=$ARG"
    fi

    if [ "$SILENT" == 'y' ]; then
        LISTCMD='featmainbranch'
    else
        LISTCMD='featstat'
    fi

    if [ "$DATESORT" == 'y' ]; then
        LISTCMD="$LISTCMD;sort=time"
    fi

    eval "$($CMDFEATCACHE parse \
        "CURRENT=$LISTCMD;state=draft$FILTER" \
        "FINALS=$LISTCMD;state=final$FILTER" \
        "INCLUDED=$LISTCMD;integrated$FILTER;sort=time")"

    echo "List local features"
    echo ""
    echo -e $TITLE"Included features"$NORMAL
    echo -e "$ERRCOL$INCLUDED$NORMAL"
    echo ""
    echo -e $TITLE"Current features"$NORMAL
    echo -e "$CURRENT"
    echo -e "$HIGHLIGHT$FINALS$NORMAL"
    echo ""

    exit 

#Finalize feature
elif [ "$DO" == 'f' ]; then
    DRAFTBRANCH="$($CMDFEATCACHE draftbranch "$FEATUREBRANCH")"
    if [ -z "$DRAFTBRANCH" ]; then
        echoerr "No draft branch found for feature $FEATURE found!"
        exit 4
    fi

    FINALS="$($CMDFEATCACHE finals "$FEATURE")"
    if [ -n "$FINALS" ]; then
        echoerr "$FEATURE is already being finalized by you or someone else." ' *'/$FEATUREFINAL branches are detected.
        echo -e "$FINALS"
        exit 5
    fi

    if DEP_FINALS=$($CMDFEATCACHE finals "$FEATURE^" 2> /dev/null); then
        if [ -z "$DEP_FINALS" ]; then
            echoerr "Dependancies must be in final state"
            echo "You must set depend feature : $($CMDFEATCACHE depend $FEATURE)"
            echo "to final state before!"
            exit 7
        fi
    fi

    #Check if repo is clean
    if ! git diff --quiet HEAD; then
        echoerr "The repository needs to be clean for this operation."
        echo "Please clean uncommited changes and try again."
        exit 6
    fi

    STARTPOINT=$(start_point $FEATUREBRANCH) || exit 1

    git branch -t $FEATUREFINAL $STARTPOINT
    git branch -f $FEATUREFINAL $DRAFTBRANCH
    #Check if STARTPOINT is in DEVREF line
    if [ $(git rev-list --count $STARTPOINT ^$DEVREF) == 0 ]; then
        git rebase -i $DEVREF $FEATUREFINAL
    else
        #Unsure there is a local start point
        git branch -f $FEATURESTART $STARTPOINT
        git rebase -i $STARTPOINT $FEATUREFINAL
    fi

    exit
elif [ "$DO" == 'm' ]; then
    FEATUREBRANCH="$($CMDFEATCACHE workingbranch "$FEATUREBRANCH")"
    if [ -z "$FEATUREBRANCH" ]; then
        echo "No working branch found to move"
        exit 5
    fi

    #Check if repo is clean
    if ! git diff --quiet HEAD; then
        echoerr "The repository needs to be clean for this operation."
        echo "Please clean uncommited changes and try again."
        exit 6
    fi

    STARTPOINT=$(start_point "$FEATUREBRANCH") || exit 1
    echo '>> '"$STARTPOINT"

    #If there is start marker or if new base does not coincide with DEVREF,
    # a start_point must be created or moved
    if git show-ref "$FEATURESTART" &> /dev/null || test "$(git rev-list --count ^$DEVREF "$MOVETO")" != 0
    then
        export NEWSTARTPOINT="$MOVETO"
    fi
    SHAFEAT=$(git rev-parse "$FEATUREBRANCH")
    if [ "$SHAFEAT" == "$STARTPOINT" ]; then
        echo "Move empty feature"
        if [ "$(git rev-list --count ^$DEVREF "$MOVETO")" != "0" ]; then
            git branch -f "$FEATURESTART" "$MOVETO"
        else
            git branch -D "$FEATURESTART" 2> /dev/null
        fi
        git checkout "$FEATUREBRANCH"
        git reset --hard "$MOVETO"
        $CMDFEATCACHE
    else
        echo git rebase --onto "$MOVETO" "$STARTPOINT" "$FEATUREBRANCH"
        git rebase --onto "$MOVETO" "$STARTPOINT" "$FEATUREBRANCH"
    fi
    exit

elif [ "$DO" == 'r' ]; then
    FEATUREBRANCH="$($CMDFEATCACHE workingbranch "$FEATUREBRANCH")"
    if [ -z "$FEATUREBRANCH" ]; then
        echo "No working branch found to move"
        exit 5
    fi

    #Check if repo is clean
    if ! git diff --quiet HEAD; then
        echoerr "The repository needs to be clean for this operation."
        echo "Please clean uncommited changes and try again."
        exit 6
    fi

    STARTPOINT=$(start_point "$FEATUREBRANCH") || exit 1
    git checkout $FEATUREBRANCH
    git rebase -i $STARTPOINT
    exit

elif [ "$DO" == 'co' ]; then
    #Check if repo is clean
    if ! git diff --quiet HEAD; then
        echoerr "The repository needs to be clean for this operation."
        echo "Please clean uncommited changes and try again."
        exit 6
    fi
    FEATUREBRANCH="$($CMDFEATCACHE mainbranch "$FEATUREBRANCH")"
    echo git checkout "$FEATUREBRANCH"
    git checkout "$FEATUREBRANCH"
    exit

elif [ "$DO" == 'u' ]; then
    FEATUREBRANCH="$($CMDFEATCACHE workingbranch "$FEATUREBRANCH")"
    if [ -z "$FEATUREBRANCH" ]; then
        echo "No working branch found to move"
        exit 5
    fi

    #Check if repo is clean
    if ! git diff --quiet HEAD; then
        echoerr "The repository needs to be clean for this operation."
        echo "Please clean uncommited changes and try again."
        exit 6
    fi

    STARTPOINT=$(start_point "$FEATUREBRANCH") || exit 1
    FEATUREBASE="$($CMDFEATCACHE smartdepend "$FEATUREBRANCH")"

    if [ -z "$FEATUREBASE" ]; then
        echo "No base on which to update"
        echo "Use featmove to specify a branch as feature base"
        exit 1
    fi
    SHAFEAT=$(git rev-parse $FEATUREBRANCH)
    #TODO Check for other refs between start point and branch end.
    if [ "$STARTPOINT" == "$FEATUREBASE" ]; then
        git checkout "$FEATUREBRANCH"
        echo "Feature is already up to date"
        exit
    elif [ "$SHAFEAT" == "$STARTPOINT" ]; then
        echo "Update empty feature"
        if [ "$(git rev-list --count ^$DEVREF $FEATUREBASE)" != "0" ]; then
            git branch -f "$FEATURESTART" "$FEATUREBASE"
        else
            git branch -D "$FEATURESTART" 2> /dev/null
        fi
        git checkout "$FEATUREBRANCH"
        git reset --hard "$FEATUREBASE"
    else
        export NEWSTARTPOINT=$FEATUREBASE
        echo git rebase --onto "$FEATUREBASE" "$STARTPOINT" "$FEATUREBRANCH"
        git rebase --onto "$FEATUREBASE" "$STARTPOINT" "$FEATUREBRANCH"
    fi
    exit

elif [ "$DO" == 'T' ]; then
    #Check if repo is clean
    if ! git diff --quiet HEAD; then
        echoerr "The repository needs to be clean for this operation."
        echo "Please clean uncommited changes and try again."
        exit 6
    fi

    git branch -f testing_track testing &> /dev/null
    if [ "$(git symbolic-ref HEAD)" == "refs/heads/testing" ]; then
        git checkout testing_track
    fi
    if lasttest=$(git config workflow.lastref) && git config workflow.multipletest &> /dev/null ; then
        git branch $lasttest testing
    fi
    git branch -f testing $DEVREF
    testname=$(unicref test$(date +%d%m%y).)
    git config workflow.lastref $testname
    git checkout testing
    if [ -n "$ARG" ]; then
        WORKFILE="test_merge_$ARG"
    else
        WORKFILE="test_merge"
    fi

    if [ -f "$GITDIR/$WORKFILE" ]; then
        source "$GITDIR/$WORKFILE"
    fi

    LIST="$($CMDFEATCACHE featmainbranch state=draft,final sort=time)"
    SELECTLIST=''
    for feat in $LIST; do
        FLAG=''
        STAT='off'
        if [[ " $MERGEDFEAT " =~ " $feat " ]]; then
            STAT=on
        elif [[ " $NOTMERGEDFEAT " =~ " $feat " ]]; then
            STAT=on
            FLAG=':(!!)'
        fi
        SELECTLIST=" $feat $(basename $feat)$FLAG $STAT $SELECTLIST"
    done
    if ! multiselect "$SELECTLIST" "Select features you want to merge in test branch"; then
        SELECTED=''
    else
        SELECTED=$(sed 's/"//g;s/\\#/#/g' "$TMPFILE")
    fi

    if [ -z "$SELECTED" ]; then
        echo ""
        echo "No merge selected"
        exit
    fi

    echo ""
    echo "Performing selected merges : "
    MERGEDFEAT=''
    NOTMERGEDFEAT=''
    #Don't open editor in git merge
    export GIT_MERGE_AUTOEDIT=no

    for feat in $SELECTED; do
        echo ""
        repeatchar 60 '#'
        echo -e "#    $HIGHLIGHT Merging $feat$NORMAL"
        repeatchar 60 '#'
        if git merge $feat; then
            MERGEDFEAT="$MERGEDFEAT$feat "
        else
            git reset --hard
            echo -e "$ERRCOL$feat could not be merged because of a conflict.$NORMAL"
            NOTMERGEDFEAT="$NOTMERGEDFEAT$feat "
        fi
    done
    echo -e ""
    repeatchar 60 '='
    echo 'Test branch generated by git feature with merge' > "$TMPFILE"
    echo '' >> "$TMPFILE"
    if [ -n "$MERGEDFEAT" ]; then
        echo -e "$TITLE Following features where successfully merged:$NORMAL$BOLD"
        echo "* Following features where successfully merged:" >> "$TMPFILE"
        for feat in $MERGEDFEAT; do echo -e "   > $feat"; done
        for feat in $MERGEDFEAT; do echo -e "   > $feat"; done >> "$TMPFILE"
        echo -e "$NORMAL"
        echo "" >> "$TMPFILE"
    fi
    echo -e ""
    if [ -n "$NOTMERGEDFEAT" ]; then
        echo -e "$TITLE Following features failled:$ERRCOL"
        echo -e "* Following features failled:" >> "$TMPFILE"
        for feat in $NOTMERGEDFEAT; do echo -e "   > $feat"; done
        for feat in $NOTMERGEDFEAT; do echo -e "   > $feat"; done >> "$TMPFILE"
        echo -e "$NORMAL"
    fi

    git commit --allow-empty -F "$TMPFILE"
    git branch -f testing_track

    echo "MERGEDFEAT='$MERGEDFEAT'" > "$GITDIR/$WORKFILE"
    echo "NOTMERGEDFEAT='$NOTMERGEDFEAT'" >> "$GITDIR/$WORKFILE"
    repeatchar 60 '='

    exit

elif [ "$DO" == 'L' ]; then
    $CMDFEATCACHE featmainbranch sort=time
    exit

elif [ "$DO" == 't' ]; then
    echo FEATURE      : $FEATURE
    echo DEVREF       : $DEVREF
    echo STARTNAMESPACE  : $STARTNAMESPACE
    echo DRAFTNAMESPACE  : $DRAFTNAMESPACE
    echo FINALNAMESPACE  : $FINALNAMESPACE
    echo FEATURESTART : $FEATURESTART
    echo FEATUREDRAFT : $FEATUREDRAFT
    echo FEATUREFINAL : $FEATUREFINAL
    echo FEATUREDIR   : $FEATUREDIR
    echo FEATUREBRANCH : $FEATUREBRANCH
    echo FEATURENAMESPACE : $FEATURENAMESPACE

    echoimportant 'start > '$(start_point $FEATUREBRANCH)
    echowarn "Do nothing ..."
    pwd
    echo "$GITDIR/"
    readlink -f "$GITDIR"
    exit

else
    if $CMDFEATCACHE isfeaturebranch "$FEATURE"; then
        echoerr "The name $FEATURE has been found in existing branches"
        echo "Choose another name for your new feature"
        exit 5
    fi

    if [ -z "$FOLLOW" ]; then
        FOLLOW="$DEVREF"
    fi
fi

DISTANCE=$(git rev-list --count $DEVREF ^$FOLLOW)
if [ ! "$DISTANCE" == 0 ]; then
    echoerr "Your base must contain the main devel branch : $DEVREF"
    echo "Ensure your base is correct and / or rebase it if needed before creating your new feature"
    exit 7
fi

DEVREFHASH=$(git rev-parse $DEVREF)

if [ ! "$(git rev-parse $FOLLOW)" == "$DEVREFHASH" ]; then
    echoerr "Provide distant start point"
    git branch $FEATURESTART $FOLLOW
fi
git branch -t $FEATUREDRAFT $FOLLOW
git config branch.$FEATUREDRAFT.rebase true

echo "You can now implement your new feature in branch $FEATUREDRAFT"

#Check if repo is clean
if ! git diff --quiet HEAD; then
    echowarn "It can't be checked out now because your repository is not clean now"
    echo "you can get it by > git checkout $FEATUREDRAFT"
    echo "but you should FIRST CLEAN YOUR REPOSITORY"
else
    git checkout $FEATUREDRAFT
fi

$CMDFEATCACHE
